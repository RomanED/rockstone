# Задача 2
Реализация функциональности
Задание:
Реализовать мини-модуль TopTracker, который хранит N последних действий игроков с привязкой ко времени.


В модуле должны быть реализованы операции: добавление нового действия, удаление старых действий по истечении тайм-аута (очистка "просроченных" записей), и получение текущего списка сохранённых действий.


Использовать стандартные контейнеры (например, std::deque, std::unordered_map) – необходимо объяснить выбор тех или иных структур данных.


Минимизировать внешние зависимости – желательно использовать только стандартную библиотеку C++ и, при необходимости, Boost (например, Boost.Timer/Chrono) для работы со временем.


Реализовать unit-тесты для разработанного модуля TopTracker.


Код модуля и тестов должен быть написан в том же стиле, что и существующие файлы проекта (Client.cpp/h), включая соглашения по отступам, именованию и общей архитектуре решения.


## Архитектура модуля

Модуль реализован как потокобезопасный класс TopTracker, хранящий временные метки действий в порядке их добавления. Ключевые решения:

1.Ядро хранения данных
    Использована структура std::deque<Entry> где:

        Entry = { действие (string), временная метка (time_point) }

        Почему deque?

            O(1) для операций push_back/pop_front

            Эффективное хранение элементов в порядке добавления

            Оптимальное удаление устаревших элементов с головы очереди

2. Механизм очистки
    Тройная стратегия удаления устаревших записей:

        При добавлении нового элемента (add())

        При явном вызове cleanup()

        При получении списка действий (get_actions())

3. Потокобезопасность

        Все публичные методы защищены std::mutex

        Использование std::lock_guard для RAII-блокировок

        mutable мьютекс для константных операций очистки

4. Управление временем

        Внутреннее хранение таймаута в миллисекундах

        Шаблонный конструктор для поддержки любых единиц:

```
TopTracker tracker(100, std::chrono::minutes(5)); // 5 минут
TopTracker tracker(50, std::chrono::seconds(30)); // 30 секунд
```

## Ключевые технические решения

- Автоматическая очистка

```
void cleanup_impl() const {
    while (!entries.empty() && entries.front().timestamp < threshold) {
        entries.pop_front();
    }
}
```

    Вызывается перед критическими операциями

    Гарантирует актуальность данных

- Двойные ограничения

    По времени: удаление старше N миллисекунд

    По количеству: ограничение max_entries элементов

    Оптимальное сочетание через while-циклы

- Потокобезопасный интерфейс

- Тестовое покрытие
7 категорий тестов:

    Инициализация состояния

    Добавление элементов

    Ограничение размера

    Ручная/автоматическая очистка

    Сохранение порядка

    Многопоточные операции

    Стресс-тестирование
    
## Зависимости

    Стандартная библиотека C++20:

        <chrono> (работа со временем)

        <mutex> (потокобезопасность)

        <deque> (основное хранилище)

        <vector>, <string> (интерфейсы)

    Тестирование: Google Test 1.14+

    Система сборки: CMake 3.14+
    
## Инструкция по сборке и запуску

### Клонирование и сборка

```
git clone <репозиторий>
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . --parallel
```

### Запуск тестов
./TopTrackerTests

### Пример использования (в коде)
```
#include "TopTracker.h"

TopTracker activity_log(500, std::chrono::minutes(10));
activity_log.add("Player_123 picked up sword");
auto actions = activity_log.get_actions();
```
### Примеры использования

// Создание трекера на 200 записей с таймаутом 15 минут
TopTracker tracker(200, std::chrono::minutes(15));

// Добавление действия
tracker.add("Player_456 crafted potion");

// Получение всех действий
for (const auto& action : tracker.get_actions()) {
    std::cout << action << std::endl;
}

// Принудительная очистка старых записей
tracker.cleanup();
